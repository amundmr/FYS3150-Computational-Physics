\documentclass[../main.tex]{subfiles}

\begin{document}
\section{Theory} \label{sec:theory}
\subsection{Wavefunction of Helium} \label{sec:QMProb}
The single-particle wave function of an electron $i$ in the $1s$ state is given in terms of a dimensionless variable (the wave function is not normalized) as

\[\psi_{1s}(\vec{r}_i) = e^{-\alpha r_i}\]
Where the electron position $\vec{r}_i$ is
\[\vec{r}_i = x_i \vec{e}_x + y_i \vec{e}_y + z_i \vec{e}_z\]
and its distance from the origin $r_i$ is
\[r_i = \sqrt{x_i^2 + y_i^2 + z_i^2}\]

$\alpha$ is a parameter set to 2, which corresponds to the carge of the Helium atom, $Z = 2$.


For our system with two electrons, we have the product of the two $1s$ wave functions defined as
\[\Psi(\vec{r}_1, \vec{r}_2) = e^{-\alpha(r_1 + r_2)}\]

This leads to the integral which will be solved nummericaly with the  different methods mentioned earlier.
The value of the integral corresponds to the expectation value of the  energy between the two electrons repelling each other due to Columb interactions.

\[\langle \frac{1}{|\vec{r}_1 - \vec{r}_2|} \rangle = \int_{\infty}^\infty d\vec{r}_1 d\vec{r}_2 e^{-2\alpha(r_1 + r_2)} \frac{1}{\vec{r_1} - \vec{r_2}}\]
\vspace{1cm}

This is the integration that will be performed numerically in multiple ways in this paper. The analytical result is $5\pi/16^2$.

\subsection{Gaussian Quadrature} \label{sec:GQ}
The main idea of Gaussian quadrature is to integrate over a set of points $x_i$ not equally spaced with weights $w_i$, which are calculated in \href{https://github.com/kmaasrud/Project-3/blob/master/code/Gauss-Quadrature/src/gauleg.cpp}{\texttt{/code/Gauss-Quadrature/src/gauleg.cpp}}. The weights are found through orthogonal polynomials(Laguerre and Legendre polynomials) in a set interval. The points $x_i$ are chosen in a optimal sense and lie in the interval.

The intgral is approximated as
\[\int_a^b W(x)f(x) \approx \sum_{i=1}^n \omega_i f(x_i) \]

For a more detalied derivation and explanation of Gaussian quadrature see \cite{MortenMC2019}.


\subsubsection{Gauss-Legendre}\label{sec:GLQ}
Using Gauss-Legendre quadrature with Legendre polynomials will make it possible to solve the integral numerically. The first step is to change the integration limits from  $-\infty$ and $\infty$ to $-\lambda$ and $\lambda$. The $\lambda$'s are found by inserting it for $r_i$ in the expression $e^{-\alpha r_i}$ because $r_i \approx \lambda$ when $e^{-\alpha r_i} \approx 0$. From figure \ref{fig:plot}, $\lambda \in [-5,5]$ is therefor a good approximation for the integration limits.

\begin{figure}[!h]
  \includegraphics{img/expfunc_plot.png}
  \caption{Plot of wavefunction in one dimension}
  \label{fig:plot}
\end{figure}
\FloatBarrier


The  weights and mesh points are computed using \href{https://github.com/kmaasrud/Project-3/blob/master/code/Gauss-Quadrature/src/gauleg.cpp}{\texttt{/code/Gauss-Quadrature/src/gauleg.cpp}}. Eventually ending up with a sixdimensional integral, where all six integration limits are the same.

\[\int_a^b\int_a^b\int_a^b\int_a^b\int_a^b\int_a^b e^{-x}f(x)dx \approx \sum_{i=1}^n w_i f(x_i)\]

\subsubsection{Improved Gauss-Quadrature- Laguerre} \label{sec:improved_GQ}
Gauss-Legendre quadrature gets the job done, but it is unstable and unsatisfactory. By changing to spherical coordinates and  replacing Legendre- with Laguerre polynomials an improvement in accuracy is expected. The Laguerre polynomials are defined for  $x \in [0, \infty)$,and in spherical coordinates:
\\

\[ d\vec{r}_1 d\vec{r}_2 = r_1^2 dr_1 r_2^2 dr_2 dcos(\theta_1) dcos(\theta_2) d\phi_1 d\phi_2\]
\\
with

\[\frac{1}{r_{12}} = \frac{1}{\sqrt{r_1^2 + r_2^2 - 2r_1r_2cos(\beta)}} \]
\\and


\[cos(\beta) = cos(\theta_1)cos(\theta_2) + sin(\theta_1)sin(\theta_2)cos(\phi_1 - \phi_2)\]
\\

For numerical integration, the deployment of the following relation is nessecary:

\[\int_0^\infty e^{-x}f(x)dx \approx \sum_{i=1}^n w_i f(x_i)\]
where $x_i$ is the $i$-th root of the Laguerre polynomial $L_n(x)$ and the weight $w_i$ is given by
\\
\[w_i = \frac{x_i}{(n+1)^2 [L_{n+1}(x_i)]^2}\]
\\
The Laguerre polynomials are defined by Rodrigues formula:
\[L_n(x) = \frac{e^x}{n!}\frac{d^n}{dx^n}\left(e^{-x} x^n\right) = \frac{1}{n!}\left(\frac{d}{dx}-1\right)^n x^n\]
or the recursive relation:
\begin{align*}
  L_0(x) &= 1\\
  L_1(x) &= 1 - x\\
  L_{n+1}(x) &= \frac{(2n + 1 - x)L_n(x) - nL_{n-1}(x)}{n+1}\\
\end{align*}
\ref{ref:GL-quad_wiki}


\subsection{Monte Carlo}
\label{sec:MC}
KILDE:https://cs.dartmouth.edu/~wjarosz/publications/dissertation/appendixA.pdf
Monte Carlo is numerical methods dependent of a random samlping from a function in order to approximate the integral.


In general the integral, F, of a function, $f(x), x\in[a,b]$

\[F = \int_a^b f(x)dx\] \\

can be approximated by taking avarage samples of $f$ with a uniform distrubution of points in the interaval. Having N uniform random variables  $x_i \in [a,b)$ with probability distrubution function, PDF $\frac{1}{b-a}$ the Monte-Carlo approximation of $F$ is


\[\langle F^N \rangle = (b-a)\frac{1}{N-1} \sum_{i=0}^{N}  f(x_i)\]

$x_i$ is constructed

\subsubsection{Paralellization} \label{sec:theory-Paralellization}

To run the computations faster, openMP will be used to paralellize the code. This shares the workload across multiple processor threads and results in a substantional decrease in time spent for the same amount of operations. Some important remarks when doing Monte-Carlo integration in paralell is:
\begin{itemize}
 \item Create a random number generator in earch thread.
 \item Keep the summations private for each thread.
 \item Sum the private summations from each thread together after the calculations are completed.
\end{itemize}
By doing this we avoid having the threads wait for the random number generator and writing to the same memory, thereby achieving optimal speedup.
\\
The code is commented in for example \href{https://github.com/kmaasrud/Project-3/blob/master/code/Monte-Carlo/src/naiveMC.cpp}{\texttt{/code/Monte-Carlo/src/naiveMC.cpp}}.

\end{document}
